<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Lethe">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lethe">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lethe">






  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Lethe</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lethe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/CSS相关问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/11/CSS相关问题/" class="post-title-link" itemprop="http://yoursite.com/index.html">CSS相关问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-11 19:04:35" itemprop="dateCreated datePublished" datetime="2019-03-11T19:04:35+08:00">2019-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-12 13:07:30" itemprop="dateModified" datetime="2019-03-12T13:07:30+08:00">2019-03-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>Cascading Style Sheet 层叠样式表</p>
<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><ul>
<li>标签选择器</li>
<li>id选择器</li>
<li>class选择器</li>
<li>伪类选择器(first-child,nth-child)</li>
<li>子代选择器</li>
<li>兄弟选择器</li>
<li>后代选择器</li>
<li>否定选择器 :not(.link)</li>
<li>属性选择器 [attribute]</li>
<li>伪元素选择器 ::before {content:’’} 伪元素css3里面规定了用两个::</li>
</ul>
<h3 id="CSS3属性选择器"><a href="#CSS3属性选择器" class="headerlink" title="CSS3属性选择器"></a>CSS3属性选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[attribute]</td>
<td>用于选取带有指定属性的元素。</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>用于选取带有指定属性和值的元素。</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>用于选取属性值中包含指定词汇的元素。</td>
</tr>
<tr>
<td>[attribute\</td>
<td>=value]</td>
<td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>匹配属性值以指定值开头的每个元素。</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>匹配属性值以指定值结尾的每个元素。</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>匹配属性值中包含指定值的每个元素。</td>
</tr>
</tbody>
</table>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes#%E6%A0%87%E5%87%86%E4%BC%AA%E7%B1%BB%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">伪类 | MDN</a><br>常用：</p>
<ul>
<li>:hover</li>
<li>:focus</li>
<li>:after 在元素之前添加内容,也可以用来做清除浮动。</li>
<li>:before 在元素之后添加内容</li>
<li>:enabled 选择器匹配每个已启用的元素（大多用在表单元素上）。</li>
<li>:disabled 控制表单控件的禁用状态。</li>
<li>:checked 单选框或复选框被选中</li>
<li>::selection  用户选中的区域</li>
<li>:empty   一般用来隐藏内部什么都没有的元素</li>
<li>:not(selecter)</li>
<li></li>
<li>p:first-of-type </li>
<li>p:last-of-type </li>
<li>p:only-of-type </li>
<li>p:nth-of-type(n)</li>
<li>p:nth-last-of-type(n)</li>
<li></li>
<li>:nth-child(n)</li>
<li>:nth-last-child(n)</li>
<li>p:only-child </li>
</ul>
<h3 id="伪类和伪元素区别"><a href="#伪类和伪元素区别" class="headerlink" title="伪类和伪元素区别"></a>伪类和伪元素区别</h3><ul>
<li>伪类值一种状态 比如:hover</li>
<li>伪元素是一个真实存在的元素，他可以有样式有内容</li>
</ul>
<h3 id="iconfont原理"><a href="#iconfont原理" class="headerlink" title="iconfont原理"></a>iconfont原理</h3><ul>
<li>利用编码让图标编为一个字符</li>
<li>引入字体</li>
<li>利用before伪元素向页面中插入一个文字</li>
</ul>
<h3 id="css优先级计算"><a href="#css优先级计算" class="headerlink" title="css优先级计算"></a>css优先级计算</h3><ul>
<li><code>!important</code> 优先级最高，会被优先级高的<code>!important</code> 覆盖</li>
<li>行内样式会覆盖外部样式表的样式（除了<code>!important</code> ）</li>
<li></li>
</ul>
<p>!important &gt; 行内样式 &gt; ID选择器 &gt; (类选择器 | 属性选择器 | 伪类选择器 )&gt; 元素选择器</p>
<h4 id="权重等级"><a href="#权重等级" class="headerlink" title="权重等级"></a>权重等级</h4><p>每个选择器在权重级别中都有自己泾渭分明的位置。根据选择器种类的不同可以分为四类，也决定了四种不同等级的权重值.</p>
<h5 id="怎么确定权重"><a href="#怎么确定权重" class="headerlink" title="怎么确定权重"></a>怎么确定权重</h5><p>权重记忆口诀。从0开始，一个行内样式+1000，一个id+100，一个属性选择器/class或者伪类+10，一个元素名，或者伪元素+1.比如</p>
<p><img src="/images/9lg1p2cYg3Om5TQH4dZB.png" alt="upload successful"> </p>
<ol>
<li>*{}                         ====》0</li>
<li>li{}                        ====》1(一个元素)</li>
<li>li:first-line{}             ====》2(一个元素，一个伪元素)</li>
<li>ul li {}                    ====》2（两个元素）</li>
<li>ul ol+li{}                  ====》3（三个元素）</li>
<li>h1+ *[rel=up] {}            ====》11（一个属性选择器，一个元素）</li>
<li>ul ol li.red{}              ====》13（一个类，三个元素）</li>
<li>li.red.level{}              ====》21（两个类，一个元素）</li>
<li>style=””                    ====》1000(一个行内样式)</li>
<li>p {}                        ====》1（一个元素）</li>
<li>div p {}                    ====》2（两个元素）</li>
<li>.sith {}                    ====》10（一个类）</li>
<li>div p.sith{}                ====》12（一个类，两个元素）</li>
<li>#sith{}                     ====》100（一个ID选择器）</li>
<li>body #darkside .sith p {}   ====》112(1+100+10+1,一个Id选择器，一个类，两个元素)</li>
</ol>
<p>继承过来的属性优先级最低。</p>
<h3 id="浏览器解析CSS"><a href="#浏览器解析CSS" class="headerlink" title="浏览器解析CSS"></a>浏览器解析CSS</h3><p><code>.wrapper div &gt; p</code>  CSS中，浏览器查找元素是通过选择权从后往前找的， 这样做的目的是加快CSS解析速度，从后往前，排除法</p>
<p><a href="https://blog.csdn.net/qq_21397815/article/details/72874932" target="_blank" rel="noopener">浏览器解析css选择器的规则</a></p>
<h3 id="盒模式"><a href="#盒模式" class="headerlink" title="盒模式"></a>盒模式</h3><p>盒模型有两种，IE 怪异盒子模式 和 W3C标准盒子模型</p>
<p>盒模型： <code>content</code> <code>padding</code> <code>border</code> <code>margin</code></p>
<p>标准模型的宽高是指<code>content</code>区的宽高<br>怪异盒子模式 是指 content+padding+border</p>
<h3 id="CSS如何设置这两种盒模型？"><a href="#CSS如何设置这两种盒模型？" class="headerlink" title="CSS如何设置这两种盒模型？"></a>CSS如何设置这两种盒模型？</h3><p>标准盒模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box;</span><br></pre></td></tr></table></figure></p>
<p>怪异盒模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure></p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://www.cnblogs.com/libin-1/p/7098468.html" target="_blank" rel="noopener">什么是BFC</a></p>
<p>w3c对BFC的定义：</p>
<blockquote>
<p>浮动元素，绝对定位，非块级盒子的块级容器(eg：inline-blocks, table-cells,table-captions),以及overflow的值不是‘visiable’的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）</p>
</blockquote>
<p>HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：<br>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible  </p>
<h4 id="BFC可以做什么？"><a href="#BFC可以做什么？" class="headerlink" title="BFC可以做什么？"></a>BFC可以做什么？</h4><ol>
<li>避免外边距折叠（外边距折叠产生的一个条件是：两个元素同处与同一个BFC）</li>
<li>清除内部浮动<br> 原理：触发父容器的BFC，使得子div都处于父级div的BFC范围<br> 浮动元素会脱离文档流（绝对定位也会），如果一个没有高度或者height是auto的容器的子元素是浮动元素，则该容器的高度是不会被撑开的。用BFC容器可以包住浮动子元素，并且其高度会扩展至包住其子元素，在这个新的BFC中浮动元素又回归到页面的常规流之中了。<br> 可以通过伪元素，</li>
<li>避免文字环绕</li>
<li>多列布局，最后一个元素可以自适应大小<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">31.33%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">1%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  Establishing a new block formatting </span></span><br><span class="line"><span class="comment">    context in the last column */</span></span><br><span class="line"><span class="selector-class">.column</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line"><span class="attribute">overflow</span>: hidden; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>BFC布局规则：</p>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>属于同一个BFC的两个相邻的Box的margin会发生重叠</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此, 文字环绕效果，设置float</li>
<li>BFC的区域不会与float box重叠。</li>
<li>计算BFC的高度，浮动元素也参与计算</li>
</ol>
<h3 id="非布局样式"><a href="#非布局样式" class="headerlink" title="非布局样式"></a>非布局样式</h3><ul>
<li>字体、字重、颜色、大小、行高</li>
<li>背景、边框</li>
<li>滚动、换行</li>
<li>粗体、斜体、下划线</li>
<li>其他</li>
</ul>
<h3 id="行高的构成"><a href="#行高的构成" class="headerlink" title="行高的构成"></a>行高的构成</h3><ul>
<li>行高是由 line-box 组成的</li>
<li>line-box 是由一行里的 inline-box 组成的</li>
<li>inline-box中最高的那个，或字体最大的拿个决定行高</li>
</ul>
<h3 id="谈谈浮动和清除浮动"><a href="#谈谈浮动和清除浮动" class="headerlink" title="谈谈浮动和清除浮动"></a>谈谈浮动和清除浮动</h3><p>浮动的框可以向左或向右移动，<strong>直到他的外边缘碰到包含框或另一个浮动框的边框为止</strong>。 <strong>浮动框脱离文档流</strong>，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p>
<p>清除方法：</p>
<ol>
<li>父级 div 定义伪类：after 和 zoom (推荐使用，建议定义公共类，以减少 CSS 代码)</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在结尾处添加空 div 标签 clear:both<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfloat"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;<span class="attribute">float</span>:left&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>父级 div 定义 overflow:auto。 同时需要父级指定宽度</p>
<p>参考链接<a href="https://www.cnblogs.com/nxl0908/p/7245460.html" target="_blank" rel="noopener">几种常用的清除浮动方法</a></p>
<h3 id="伪元素和伪类的区别和作用？"><a href="#伪元素和伪类的区别和作用？" class="headerlink" title="伪元素和伪类的区别和作用？"></a>伪元素和伪类的区别和作用？</h3><p>伪元素:在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">"第一章："</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">"Hot!"</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>:<span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>伪类: 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>
<h3 id="before-和-after-中双冒号和单冒号有什么区别？"><a href="#before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="::before 和 :after 中双冒号和单冒号有什么区别？"></a>::before 和 :after 中双冒号和单冒号有什么区别？</h3><ul>
<li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li>
<li>伪元素在 CSS1 中已存在，当时语法是用 : 表示，如 :before 和 :after</li>
<li>后来在 CSS3 中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li>
<li>由于低版本 IE 对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li>
<li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容 IE 的老语法</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/浏览器相关问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/11/浏览器相关问题/" class="post-title-link" itemprop="http://yoursite.com/index.html">浏览器相关问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-11 19:03:09" itemprop="dateCreated datePublished" datetime="2019-03-11T19:03:09+08:00">2019-03-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-12 13:07:55" itemprop="dateModified" datetime="2019-03-12T13:07:55+08:00">2019-03-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h3><blockquote>
<p>参考： <a href="https://segmentfault.com/a/1190000012925872#articleHeader13" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012925872#articleHeader13</a>  </p>
</blockquote>
<p>浏览器内核即渲染进程是多线程，包括：GUI渲染线程，js引擎线程，事件触发线程，定时触发器线程，异步http请求线程</p>
<p><img src="/images/tnWds8ZpBUQYofiJeTRU.png" alt="upload successful">  </p>
<p>渲染线程：</p>
<ul>
<li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</li>
<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
<li>GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
</ul>
<p>JS 引擎线程：</p>
<ul>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
<li>GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<p>事件触发线程：</p>
<ul>
<li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li>
<li>，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
</ul>
<p>定时触发器线程：</p>
<ul>
<li>传说中的setInterval与setTimeout所在线程</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的,</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
<li>规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
</ul>
<p>异步http请求线程：</p>
<ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li>
</ul>
<h4 id="浏览器内核中线程之间的关系"><a href="#浏览器内核中线程之间的关系" class="headerlink" title="浏览器内核中线程之间的关系"></a>浏览器内核中线程之间的关系</h4><h5 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h5><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>
<p><strong>JS阻塞页面加载</strong>JS如果执行时间过长就会阻塞页面。<br>假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。  </p>
<p>HTML5中支持了<code>Web Worker</code>。</p>
<ul>
<li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>
<li>JS引擎线程与worker线程间通过特定的方式通信</li>
</ul>
<p><img src="/images/hCetcJu9oSaemXgYG328.png" alt="upload successful">  </p>
<h5 id="浏览器渲染流程开始"><a href="#浏览器渲染流程开始" class="headerlink" title="浏览器渲染流程开始"></a>浏览器渲染流程开始</h5><ul>
<li>解析html建立dom树</li>
<li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li>
<li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li>
<li>绘制render树（paint），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li>
</ul>
<h5 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h5><ul>
<li><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。</p>
</li>
<li><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。</p>
</li>
</ul>
<h5 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h5><p>css是由单独的下载线程异步下载的。</p>
<ul>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li>
</ul>
<h5 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h5><p>渲染步骤中就提到了<code>composite</code>概念。浏览器渲染的图层一般包含两大类：<code>普通图层</code>以及<code>复合图层</code></p>
<p>首先，普通文档流内可以理解为一个<code>复合图层</code>（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）  </p>
<p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>
<p>然后，可以通过<code>硬件加速</code>的方式，声明一个<code>新的复合图层</code>，它会单独分配资源<br>（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
<p><strong>GPU中，各个复合图层是单独绘制的，所以互不影响</strong></p>
<h5 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h5><ul>
<li>最常用的方式：<code>translate3d</code>、<code>translateZ</code>  </li>
<li><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）  </li>
<li><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），</li>
</ul>
<h5 id="硬件加速时请使用index"><a href="#硬件加速时请使用index" class="headerlink" title="硬件加速时请使用index"></a>硬件加速时请使用index</h5><p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p>
<p>原理:<br><strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</strong></p>
<p>如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p>
<h3 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h3><p>待写—-</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/HTML常见问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/11/HTML常见问题/" class="post-title-link" itemprop="http://yoursite.com/index.html">HTML常见问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-11 11:29:48 / Modified: 19:02:59" itemprop="dateCreated datePublished" datetime="2019-03-11T11:29:48+08:00">2019-03-11</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML与浏览器"><a href="#HTML与浏览器" class="headerlink" title="HTML与浏览器"></a>HTML与浏览器</h2><h3 id="DOCTYPE-作用？标准模式与兼容模式各有什么区别"><a href="#DOCTYPE-作用？标准模式与兼容模式各有什么区别" class="headerlink" title="DOCTYPE 作用？标准模式与兼容模式各有什么区别?"></a>DOCTYPE 作用？标准模式与兼容模式各有什么区别?</h3><p>DOCTYPE用于声明文档类型和DTD规范<br><code>&lt;!DOCTYPE html&gt;</code>声明位于HTML文档中的第一行，不是一个HTML标签，处于 html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>
<p>标准模式的排版 和 JS 运作模式都是以该浏览器支持的<strong>最高标准</strong>运行。<br>在兼容模式中，页面以宽松的<strong>向后兼容</strong>的方式显示,模拟老式浏览器的行为以防止站点无法工作。</p>
<p>在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容<br>HTML5不基于SGML，所以不用指定DTD</p>
<h3 id="HTML-全局属性"><a href="#HTML-全局属性" class="headerlink" title="HTML 全局属性"></a>HTML 全局属性</h3><p>全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">全局属性 | MDN</a></p>
<h3 id="canvas和svg的区别"><a href="#canvas和svg的区别" class="headerlink" title="canvas和svg的区别"></a>canvas和svg的区别</h3><p>canvas是html5提供的新元素<code>&lt;canvas&gt;</code>，而svg存在的历史要比canvas久远，已经有十几年了。svg并不是html5专有的标签，最初svg是用xml技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在H5中看似canvas与svg很像，但是，他们有巨大的差别。 </p>
<p>首先，从它们的功能上来讲，canvas可以看做是一个画布。，其绘制出来的图形为<strong>标量图</strong>，因此，可以在canvas中引入jpg或png这类格式的图片，在实际开发中，大型的网络<strong>游戏</strong>都是用canvas画布做出来的，并且canvas的技术现在已经相当的成熟。另外，我们喜欢用canvas来做一些统计用的图表，如柱状图曲线图或饼状图等。<br>而svg，所绘制的图形为<strong>矢量图</strong>，所以其用法上受到了限制。因为只能绘制矢量图，所以svg中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来<strong>做小图标</strong>。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用svg技术做出来的。</p>
<p>另外从技术发面来讲canvas里面绘制的图形不能被引擎抓取，如我们要让canvas里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。<br>而svg里面的图形可以被引擎抓取，支持事件的绑定。另外canvas中我们绘制图形通常是通过javascript来实现，svg更多的是通过标签来来实现，如在svg中绘制正矩形形就要用<rect>，这里我们不能用属性style=”width:XXX;height:XXX;”来定义。</rect></p>
<h3 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><p>定义：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，如 div 的 display 默认值为“block”，则为“块级”元素；span 默认 display 属性值为“inline”，是“行内”元素。</p>
<ul>
<li>行内元素有：a b span img input select strong em（强调的语气）</li>
<li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p</li>
<li>空元素：<ul>
<li>常见: br hr img input link meta</li>
<li>不常见: area base col command embed keygen param source track wbr</li>
</ul>
</li>
</ul>
<p>不同浏览器（版本）、HTML4（5）、CSS2 等实际略有差异<br>参考: <a href="http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements" target="_blank" rel="noopener">http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements</a></p>
<h3 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和@import 有什么区别？"></a>页面导入样式时，使用 link 和@import 有什么区别？</h3><ul>
<li>link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS;</li>
<li>页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;</li>
<li>import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题;</li>
<li>link 支持使用 js 控制 DOM 去改变样式，而@import 不支持;</li>
</ul>
<h3 id="HTML5变化"><a href="#HTML5变化" class="headerlink" title="HTML5变化"></a>HTML5变化</h3><ul>
<li><a href="http://www.w3school.com.cn/html/html5_new_elements.asp" target="_blank" rel="noopener">新的语义化元素</a><ul>
<li>header footer nav main article  section</li>
<li>删除了一些纯样式的标签</li>
</ul>
</li>
<li><a href="http://caibaojian.com/html5/form.html" target="_blank" rel="noopener">表单增强</a></li>
<li>新API<ul>
<li>离线 （applicationCache ）</li>
<li>音视频 （audio, vidio）</li>
<li>图形 （canvans）</li>
<li>实时通信（websoket）</li>
<li>本地存储（localStorage, indexDB）</li>
<li>设备能力（地图定位，手机摇一摇）</li>
</ul>
</li>
</ul>
<h3 id="em-与-i-的区别"><a href="#em-与-i-的区别" class="headerlink" title="em 与 i 的区别"></a>em 与 i 的区别</h3><ul>
<li>效果都是斜体</li>
<li>em 是语义化标签，表强调</li>
<li>i 是样式标签， 表斜体</li>
</ul>
<h3 id="哪些元素可以自闭合？"><a href="#哪些元素可以自闭合？" class="headerlink" title="哪些元素可以自闭合？"></a>哪些元素可以自闭合？</h3><ul>
<li>表单元素 input</li>
<li>img</li>
<li>br,  hr</li>
<li>meta, link</li>
</ul>
<h3 id="HTML和DOM的关系"><a href="#HTML和DOM的关系" class="headerlink" title="HTML和DOM的关系"></a>HTML和DOM的关系</h3><ul>
<li>HTML只是一个字符串</li>
<li>DOM由HTML解析而来</li>
<li>JS可以维护DOM</li>
</ul>
<h3 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h3><ul>
<li>用正确的标签做正确的事情。</li>
<li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li>
<li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
<li>可以提升可访问行和互操作性</li>
<li>改进搜索引擎优化</li>
<li>让代码更好维护，为了统一规范与新功能的出现</li>
</ul>
<h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
<li><p>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</p>
<blockquote>
<p><code>cookie</code> 如果要跨访问可以通过<code>setPath()</code>和<code>setDomain()</code>  </p>
<ol>
<li>可在同一应用服务器内共享方法：设置cookie.setPath(“/“);   </li>
<li>跨域共享cookie的方法：设置cookie.setDomain(“.xxx.com”);</li>
</ol>
</blockquote>
</li>
<li><p>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</p>
</li>
<li>存储大小：<ul>
<li>cookie 数据大小不能超过 4k。</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
</ul>
</li>
<li>有效期（生命周期）：<ul>
<li>localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>
<li>sessionStorage: 数据在当前浏览器窗口关闭后自动删除。</li>
<li>cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
<li>共享<ul>
<li>sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享</li>
</ul>
</li>
</ul>
<h3 id="html-中-title-属性和-alt-属性的区别？"><a href="#html-中-title-属性和-alt-属性的区别？" class="headerlink" title="html 中 title 属性和 alt 属性的区别？"></a>html 中 title 属性和 alt 属性的区别？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">alt</span>=<span class="string">"alt信息"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>当图片不输出信息的时候，会显示 alt 信息 鼠标放上去没有信息，当图片正常读取，不会出现 alt 信息。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">alt</span>=<span class="string">"alt信息"</span> <span class="attr">title</span>=<span class="string">"title信息"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>当图片不输出信息的时候，会显示 alt 信息 鼠标放上去会出现 title 信息；</li>
<li>当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。</li>
<li>除了纯装饰图片外都必须设置有意义的值，搜索引擎会分析。</li>
</ul>
<h4 id="另外还有一些关于-title-属性的知识："><a href="#另外还有一些关于-title-属性的知识：" class="headerlink" title="另外还有一些关于 title 属性的知识："></a>另外还有一些关于 title 属性的知识：</h4><ul>
<li>title 属性可以用在除了 base，basefont，head，html，meta，param，script 和 title 之外的所有标签。</li>
<li>title 属性的功能是提示。额外的说明信息和非本质的信息请使用 title 属性。title 属性值可以比 alt 属性值设置的更长。</li>
<li>title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。</li>
</ul>
<h3 id="为什么我们要弃用table标签？"><a href="#为什么我们要弃用table标签？" class="headerlink" title="为什么我们要弃用table标签？"></a>为什么我们要弃用table标签？</h3><p>table的缺点在于服务器把代码加载到本地服务器的过程中，本来是加载一行执行一行，但是table标签是里面的东西<strong>全都下载完之后才会显示出来</strong>，那么如果图片很多的话就会导致网页一直加载不出来，除非所有的图片和内容都加载完。如果要等到所有的图片全都加载完之后才显示出来的话那也太慢了，所以table标签现在我们基本放弃使用了。</p>
<p>使用table布局，一个很小的改动可能造成整个table重新布局，引起回流</p>
<h3 id="head-元素"><a href="#head-元素" class="headerlink" title="head 元素"></a>head 元素</h3><p>head子元素大概分为三类，分别是：</p>
<ul>
<li>描述网页基本信息的</li>
<li>指向渲染网页需要其他文件链接的</li>
<li>各大厂商根据自己需要定制的</li>
</ul>
<h4 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h4><p>一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。</p>
<ul>
<li>文档标题（浏览器标签中显示的文本）：<code>&lt;title&gt;深入了解 head 元素&lt;/title&gt;</code></li>
<li>编码格式：<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>如果你的页面出现乱码，那一般就是编码格式不对</li>
<li>视窗设置：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></li>
<li>搜索引擎优化相关内容： <code>&lt;meta name=&quot;description&quot; content=“帮助你深层次了解HTML文档结构”&gt;</code></li>
<li>IE浏览器版本渲染设置：<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</code></li>
</ul>
<h4 id="厂商定制"><a href="#厂商定制" class="headerlink" title="厂商定制"></a>厂商定制</h4><p>同样分享页面到QQ的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"name"</span> <span class="attr">content</span>=<span class="string">"这是分享的标题"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">itemprop</span>=<span class="string">"image"</span> <span class="attr">content</span>=<span class="string">"http://imgcache.qq.com/qqshow/ac/v4/global/logo.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">itemprop</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"这是要分享的内容"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="移动端项目需要注意的4个问题"><a href="#移动端项目需要注意的4个问题" class="headerlink" title="移动端项目需要注意的4个问题"></a>移动端项目需要注意的4个问题</h3><h4 id="meta中设置viewport"><a href="#meta中设置viewport" class="headerlink" title="meta中设置viewport"></a>meta中设置viewport</h4><p>视窗宽度<br>一个移动专属的Meta值，用于定义视口的各种行为，viewport 用于定义视口的各种行为。</p>
<p><img src="/images/eYhvYiX1V3h8jGEDyc77.png" alt="upload successful">  </p>
<p>阻止用户手滑放大或缩小页面，需要在 index.html中添加meta元素,设置viewport。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="移动端适配px2rem"><a href="#移动端适配px2rem" class="headerlink" title="移动端适配px2rem"></a>移动端适配px2rem</h4><p>根据根元素的字体大小计算尺寸单位，通过不同分辨率的屏幕改变html的font-size来实现rem的响应式布局。<br><strong>deviceWidth=设备逻辑像素/(dpr * scale)；</strong></p>
<h4 id="CSS样式统一问题"><a href="#CSS样式统一问题" class="headerlink" title="CSS样式统一问题"></a>CSS样式统一问题</h4><p>我们需要重置页面样式，因为在不同的手机浏览器上，默认的css样式不是统一的。 解决方法：使用reset.css重置所有元素的默认样式</p>
<h4 id="一像素边框问题"><a href="#一像素边框问题" class="headerlink" title="一像素边框问题"></a>一像素边框问题</h4><p>有的手机分辨率比较高，是2倍屏或3倍屏，手机上的浏览器就会把CSS中的1像素值展示为2个或3个物理宽度 解决方法： 添加一个border.css库，将利用<strong>scroll缩放的原理</strong>将边框重置。当我们需要使用一像素边框时只需要在标签上添加对应类名，如设置底部一像素边框就在标签上加入”border-bottom”的class名</p>
<h4 id="300毫秒点击延迟问题"><a href="#300毫秒点击延迟问题" class="headerlink" title="300毫秒点击延迟问题"></a>300毫秒点击延迟问题</h4><p>在移动端开发中，某些机型上使用click事件会延迟300ms才执行，这样影响了用户体验。 解决方法： 引入<a href="https://www.jianshu.com/p/05b142d84780" target="_blank" rel="noopener">fastclick.js</a>。</p>
<h4 id="点透问题"><a href="#点透问题" class="headerlink" title="点透问题"></a>点透问题</h4><p>由于移动端的300ms延迟的问题，如果有个元素触发了touch事件，并且隐藏了，由于延迟的问题，click事件就变成该元素下方的某个按钮或者链接，就会产生链接跳转或者触发另一操作，就是点透问题。<br>点透问题一般的解决方法有：消耗掉touch后面的click事件，可以个接住，或者那个东西挡住，或者延迟隐藏，或者不要混用touch和click</p>
<h3 id="HTML5-的-form-如何关闭自动补全功能？"><a href="#HTML5-的-form-如何关闭自动补全功能？" class="headerlink" title="HTML5 的 form 如何关闭自动补全功能？"></a>HTML5 的 form 如何关闭自动补全功能？</h3><p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>
<h3 id="如何实现浏览器内多个标签页之间的通信-阿里"><a href="#如何实现浏览器内多个标签页之间的通信-阿里" class="headerlink" title="如何实现浏览器内多个标签页之间的通信? (阿里)"></a>如何实现浏览器内多个标签页之间的通信? (阿里)</h3><blockquote>
<p>参考 <a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5" target="_blank" rel="noopener">https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5</a></p>
<ul>
<li>webSocket<br>全双工(full-duplex)通信自然可以实现多个标签页之间的通信。<br>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。<br>WebSocket连接必须由浏览器发起，<br>特点：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li>
</ul>
</blockquote>
<ul>
<li><p>ShareWorker<br>html5浏览器的新特性SharedWorker  （同源限制）<br>ShareWorker : 通过shareWorker我们可以创建共享线程，即不同的页面使用同一个ShareWorkder，不同的页面中进行数据的共享和传递</p>
</li>
<li><p>调用localStorage<br>localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。  </p>
<p>监听onstorage以及storage事件</p>
</li>
<li>cookie<br>同源的情况下，可以判断值是否变化来传递信息</li>
</ul>
<h3 id="webSocket-如何兼容低浏览器？-阿里"><a href="#webSocket-如何兼容低浏览器？-阿里" class="headerlink" title="webSocket 如何兼容低浏览器？(阿里)"></a>webSocket 如何兼容低浏览器？(阿里)</h3><ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR</li>
</ul>
<h3 id="title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？"><a href="#title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别？" class="headerlink" title="title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？"></a>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</h3><ul>
<li>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li>
<li>strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong 会重读，而 b 是展示强调内容。</li>
<li>i 内容展示为斜体，em 表示强调的文本；</li>
</ul>
<p>Physical Style Elements – 自然样式标签</p>
<p>b, i, u, s, pre</p>
<p>Semantic Style Elements – 语义样式标签</p>
<p>strong, em, ins, del, code</p>
<p>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p>
<h3 id="html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5-有哪些新特性、移除了那些元素？如何处理-HTML5-新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><ul>
<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等。<br>功能的增加：</p>
<ul>
<li>绘画 canvas</li>
<li>用于媒介播放的 video 和 audio 元素</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术 webworker, websocket, Geolocation</li>
</ul>
</li>
<li>移除的元素：<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
</li>
<li><p>支持 HTML5 新标签：</p>
<ul>
<li>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，</li>
<li>可以利用这一特性让这些浏览器支持 HTML5 新标签，</li>
<li>浏览器支持新标签后，还需要添加标签默认的样式。</li>
<li><p>当然也可以直接使用成熟的框架、比如 html5shim;</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script&gt;</span></span><br><span class="line"><span class="comment">    src = 'http://html5shim.googlecode.com/svn/trunk/html5.js'</span></span><br><span class="line"><span class="comment">  &lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如何区分 HTML5： DOCTYPE 声明\新增的结构元素\功能元素</p>
</li>
</ul>
<h3 id="HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h3><p>离线的应用，相比普通web应用会多一个描述文件，用于描述哪些文件需要被缓存，或者不被缓存。该描述文件的扩展名<code>.appcache</code>,通过解析这个文件，浏览器就会知道缓存哪些文件</p>
<p>如何使用：</p>
<ol>
<li>页面头部像下面一样加入一个 manifest 的属性；</li>
<li>在 cache.manifest 文件的编写离线存储的资源</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#v1.0</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">assets/logo.png</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure>
<h3 id="离线缓存后如何对文件进行更新？service-worker"><a href="#离线缓存后如何对文件进行更新？service-worker" class="headerlink" title="离线缓存后如何对文件进行更新？service worker"></a>离线缓存后如何对文件进行更新？service worker</h3><p><code>service worker</code>是HTML5的新API<br>service worker 主要提供了四类的功能：</p>
<ol>
<li>后台消息传递  </li>
<li>网络代理  </li>
<li>离线缓存</li>
<li>消息推送</li>
</ol>
<p><code>service worker</code>是浏览器后台的独立进程，不直接参与DOM操作，但是可以用于postMessage 与页面通信。开发者可以灵活的操作缓存那些文件，替换哪些文件。</p>
<h3 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h3><ul>
<li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>
<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
</ul>
<p>在离线状态时，操作 window.applicationCache 进行需求实现。</p>
<p>参考链接：<a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener">HTML5 离线缓存-manifest 简介</a></p>
<h3 id="iframe-有那些缺点？"><a href="#iframe-有那些缺点？" class="headerlink" title="iframe 有那些缺点？"></a>iframe 有那些缺点？</h3><ul>
<li>iframe 会阻塞主页面的 Onload 事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO;</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
</ul>
<p>使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript</p>
<p>动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p>
<h3 id="Label-的作用是什么？是怎么用的？"><a href="#Label-的作用是什么？是怎么用的？" class="headerlink" title="Label 的作用是什么？是怎么用的？"></a>Label 的作用是什么？是怎么用的？</h3><p>label 标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"Name"</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text“name</span>=<span class="string">"Name"</span> <span class="attr">id</span>=<span class="string">"Name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"B"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><ul>
<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</li>
</ul>
<h3 id="如何在页面上实现一个圆形的可点击区域？"><a href="#如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="如何在页面上实现一个圆形的可点击区域？"></a>如何在页面上实现一个圆形的可点击区域？</h3><ul>
<li>map+area 或者 svg</li>
<li>border-radius</li>
<li>纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>
<h3 id="实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:1px;overflow:hidden;background:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/前端模块化组件化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/05/前端模块化组件化/" class="post-title-link" itemprop="http://yoursite.com/index.html">前端模块化组件化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-05 20:51:37" itemprop="dateCreated datePublished" datetime="2019-03-05T20:51:37+08:00">2019-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-15 10:28:12" itemprop="dateModified" datetime="2019-03-15T10:28:12+08:00">2019-03-15</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>参考 <a href="https://segmentfault.com/a/1190000015437724" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015437724</a></p>
</blockquote>
<p>前端工程化：</p>
<ol>
<li>技术选型</li>
<li>构建优化</li>
<li>js css模块化</li>
</ol>
<h2 id="模块化的意义"><a href="#模块化的意义" class="headerlink" title="模块化的意义"></a>模块化的意义</h2><p>模块化主要体现的是一种分而治之的思想，分而治之就是将一个大问题分解成多个独立的的小问题，最后组合就是大问题的答案。  </p>
<p>模块化则是前端最流行的分治手段，模块化可以对功能进行划分，有利于代码的复用和维护。有利于提高团队开发效率</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><ul>
<li>web sites慢慢变成了web app</li>
<li>随着项目的扩大，代码量越来越大，代码越来越复杂</li>
<li>对代码、文件的高度解耦的要求</li>
<li>优化上，希望减少http请求</li>
</ul>
<p>随着前端应用越来越复杂，模块化在前端是很有必要的。</p>
<h2 id="前端模块化历史和方案"><a href="#前端模块化历史和方案" class="headerlink" title="前端模块化历史和方案"></a>前端模块化历史和方案</h2><p>早起的模块化的方案很简单，就是通过命名空间，匿名闭包的方式，或module模式模拟类提供私有和共有方法来实现模块化，但是这些模块都不是以文件为单位，而是以对象为单位。</p>
<h4 id="同步加载CommonJS"><a href="#同步加载CommonJS" class="headerlink" title="同步加载CommonJS"></a>同步加载CommonJS</h4><p>比如node.js，使用的便是CommomJS规范。通过require，module.exports，exports来进行导入和导出，这里exports是module.exports的一个引用。  </p>
<p>CommonJS的规范： 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>
<h4 id="异步加载-AMD-Asynchronous-Module-Definition，异步模块定义"><a href="#异步加载-AMD-Asynchronous-Module-Definition，异步模块定义" class="headerlink" title="异步加载 AMD (Asynchronous Module Definition，异步模块定义)"></a>异步加载 AMD (Asynchronous Module Definition，异步模块定义)</h4><p>采用异步方式加载模块，通过define来定义一个模块，通过require来引入模块，模块的加载不影响后面语句的执行，所有依赖于这些模块的语句都写在一个回调函数中，加载完毕后，这个回调函数才运行</p>
<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范</p>
<h4 id="CMD-Common-Module-Definition，通用模块定义"><a href="#CMD-Common-Module-Definition，通用模块定义" class="headerlink" title="CMD (Common Module Definition，通用模块定义)"></a>CMD (Common Module Definition，通用模块定义)</h4><ul>
<li>AMD提倡依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>CMD提倡就近依赖（按需加载），在用到某个模块的时候再去require进来。</li>
</ul>
<h4 id="规范的实现库"><a href="#规范的实现库" class="headerlink" title="规范的实现库"></a>规范的实现库</h4><p>AMD规范的require.js与CMD规范的sea.js</p>
<blockquote>
<p>require.js主要解决的问题：<br>管理文件之间的依赖性<br>避免浏览器因为加载依赖而停止页面渲染，失去响应。  </p>
</blockquote>
<h3 id="es6-原生的模块化方案"><a href="#es6-原生的模块化方案" class="headerlink" title="es6 原生的模块化方案"></a>es6 原生的模块化方案</h3><p><strong><em>import export/export default</em></strong></p>
<p>es6的设计思想是尽量的使得在编译的时候就能确定依赖关系</p>
<h3 id="模块化打包工具webpack"><a href="#模块化打包工具webpack" class="headerlink" title="模块化打包工具webpack"></a>模块化打包工具webpack</h3><p>组件化、模块化开发的模式产生有个问题必然会产生，就是如何把模块、组件加载组合到一起。</p>
<p>本质上webpack是一个现代JavaScript应用程序的静态模块打包器。它递归的构建一个依赖关系图，其中包含应用程序的每个模块，然后将这些模块打包成一个或多个bundle.js。<br>webpack 支持 CommonJS，AMD，ES6等规范，所以我们在代码中可以使用多种模块加载规范，而且通过loader，它不仅可以处理JavaScript，还可以处理像css，图片等等的静态资源。</p>
<p>webpack的优势<br>1、支持CommonJS 和 AMD 模块。<br>2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader支持ES6<br>3、可以通过配置，打包成多个文件。有效的利用浏览器的缓存。<br>4、将样式文件和图片等静态资源视为模块进行打包。配合loader加载器，对资源进行处理。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件化主要要针对的是UI组件的分治，可以提高代码复用性，有利于扩展，团队协作  </p>
<p>如何划分：<br>页面上每个独立可视的可交互区域视为组件<br>每个组件构建的时候对于一个工程目录，组件所需的资源在这个目录下维护，<br>组件不依赖其他组件 ，高内聚低耦合<br>功能封装，组件不涉及具体的功能逻辑</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Vue生命周期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Vue生命周期/" class="post-title-link" itemprop="http://yoursite.com/index.html">Vue生命周期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-01 20:17:25 / Modified: 20:52:34" itemprop="dateCreated datePublished" datetime="2019-03-01T20:17:25+08:00">2019-03-01</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/gzzSWn1DQXAB8dQKewns.png" alt="upload successful"> </p>
<p><img src="/images/s46rZQyYywwx5vn8LWaz.png" alt="upload successful">    </p>
<ul>
<li>初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数</li>
<li>当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数</li>
<li>当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数</li>
<li>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行</li>
</ul>
<p>1、created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态<br>2、mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染<br>完毕，可以用 vm.$nextTick   </p>
<h4 id="父子组件生命周期："><a href="#父子组件生命周期：" class="headerlink" title="父子组件生命周期："></a>父子组件生命周期：</h4><p>1、仅当子组件完成挂载后，父组件才会挂载<br>2、当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）<br>3、父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）<br>4、销毁父组件时，先将子组件销毁后才会销毁父组件</p>
<h3 id="兄弟组件的生命周期："><a href="#兄弟组件的生命周期：" class="headerlink" title="兄弟组件的生命周期："></a>兄弟组件的生命周期：</h3><p>1、组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行<br>2、当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的</p>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>1、mixin中的生命周期与引入该组件的生命周期是仅仅关联的，且mixin的生命周期优先执行 ，顺序执行<br>2、自身 data 优先级高于混入的 data 属性</p>
<blockquote>
<p>参考 <a href="https://funteas.com/topic/5af41cf689f8723b0779ea0a" target="_blank" rel="noopener">https://funteas.com/topic/5af41cf689f8723b0779ea0a</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/Vue3-0-数据绑定Proxy/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/Vue3-0-数据绑定Proxy/" class="post-title-link" itemprop="http://yoursite.com/index.html">Vue3.0使用Proxy数据绑定</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-01 18:52:39" itemprop="dateCreated datePublished" datetime="2019-03-01T18:52:39+08:00">2019-03-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-06 17:41:59" itemprop="dateModified" datetime="2019-03-06T17:41:59+08:00">2019-03-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h2><p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。通过<code>Object.defineProperty</code> 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发响应的监听回调。<br>1、需要一个Observer，对数据对象的所有属性进行监听，如果有变动可将最新值通知给订阅者<br>2、需要指令解析器，对每个节点指令进行扫面解析，根据模板指令替换数据，以及绑定对应的更新函数<br>3、需要现象watcher 作为 Observer和指令解析器的桥梁，能够订阅并收到每个属性变动</p>
<p>具体实现代码（<a href="https://github.com/canfoo/self-vue/tree/master/v3）" target="_blank" rel="noopener">https://github.com/canfoo/self-vue/tree/master/v3）</a></p>
<p><img src="/images/M13R3dqssOEDHa5MGgya.png" alt="upload successful"></p>
<p><img src="/images/4BiPYa1MSwTUQBcgk0jY.png" alt="upload successful">  </p>
<blockquote>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
</blockquote>
<p>使用<code>Object.defineProperty</code>存在一些缺点：<br>1、在vue中，无法监控到数组下标的变换，不能实时响应,<a href="https://segmentfault.com/a/1190000015783546" target="_blank" rel="noopener">因为性能问题</a>。<br>2.<code>Object.defineProperty</code>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历.Vue里，是通过递归以及遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。</p>
<h2 id="Vue3-0-使用Proxy进行双向数据绑定"><a href="#Vue3-0-使用Proxy进行双向数据绑定" class="headerlink" title="Vue3.0 使用Proxy进行双向数据绑定"></a>Vue3.0 使用Proxy进行双向数据绑定</h2><blockquote>
<p>Proxy 是es6的新特性，意为代理，可以在目标对象前架设一层拦截，外界对该对象的访问，都必须通过这层拦截，这提供了一种机制，可以对外界的访问进行过滤和改写。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/images/G06rMi8KPINNtOEi1me5.png" alt="upload successful"> </p>
<blockquote>
<p>Proxy提供了13中数据劫持的方法，handler对象 常用的方法： set,get,has,construct<br>上面使用到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener"><code>Reflect</code></a>对象是es6新增的对象，它提供拦截 JavaScript 操作的方法。这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。<br>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
</blockquote>
<blockquote>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。  </p>
</blockquote>
<blockquote>
<p>（3） 让Object操作都变成函数行为。</p>
</blockquote>
<blockquote>
<p>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。  </p>
</blockquote>
<blockquote>
<p>参考  <a href="https://segmentfault.com/a/1190000017397797#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017397797#articleHeader1</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/理解js作用域/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/28/理解js作用域/" class="post-title-link" itemprop="http://yoursite.com/index.html">var let const 作用域理解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-28 20:20:16" itemprop="dateCreated datePublished" datetime="2019-02-28T20:20:16+08:00">2019-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-05 20:50:46" itemprop="dateModified" datetime="2019-03-05T20:50:46+08:00">2019-03-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>参考 <a href="http://es6.ruanyifeng.com/#docs/let#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener">es6 块级作用域</a><br><a href="https://juejin.im/post/5c76310c5188254046012189?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">重读《深入理解ES6》 —— 块级作用域</a></p>
</blockquote>
<h1 id="1-变量作用域"><a href="#1-变量作用域" class="headerlink" title="1. 变量作用域"></a>1. 变量作用域</h1><p>变量的作用域是指源程序定义该变量的区域，JavaScript目前有全局作用域，函数作用域和块级作用域。<br>类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，这个称为块级作用域。es5只有全局作用域和函数作用域，到es6新增块级作用域</p>
<h2 id="1-1-声明提前"><a href="#1-1-声明提前" class="headerlink" title="1.1 声明提前"></a>1.1 声明提前</h2><p>在JavaScript函数里面<code>var</code>声明所有的变量都会被提前至函数体顶部（不包括赋值操作），这意味着变量可以在未声明前使用  </p>
<p><strong>函数声明会被提升至代码顶部，接下来才是变量声明提前</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(scope) <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">'local'</span></span><br><span class="line">	<span class="built_in">console</span>.log(scope) <span class="comment">//local</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
<p>上面的代码第一行会输出<code>undefined</code>，这是因为函数内部的变量优先级高于同名的全局变量，声明提前导致了局部变量遮盖了全局变量。上面的代码真实的执行顺序如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明会被提到代码顶部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> scope</span><br><span class="line">   	<span class="built_in">console</span>.log(scope) <span class="comment">//undefined</span></span><br><span class="line">       scope = <span class="string">'local'</span></span><br><span class="line">   	<span class="built_in">console</span>.log(scope) <span class="comment">//local</span></span><br><span class="line">   &#125;</span><br><span class="line">	<span class="keyword">var</span> scope  </span><br><span class="line">   scope = <span class="string">'global'</span></span><br><span class="line">   f()</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/3q7AD8rHieKwXX8arEne.png" alt="upload successful"> </p>
<p>（直接用的变量会被挂载到全局对象上，这种变量未执行前不可使用）</p>
<h2 id="1-2块级作用域"><a href="#1-2块级作用域" class="headerlink" title="1.2块级作用域"></a>1.2块级作用域</h2><p>上面的例子可以看出没有了块级作用域的情况下内层变量可能会覆盖外层变量，还可能导致用来计数的循环变量泄露为全局变量。变量提升的机制也不大符合我们的编码习惯，因此在es6中引入了块级作用域的概念。  </p>
<p><code>let</code> 和 <code>const</code> 声明的变量拥有块级作用域 ，用这种方法声明的变量会把变量的作用域限制在当前的代码块中,<strong>不存在变量提升，只能在声明后使用</strong>，<strong>不允许</strong>，<strong>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、变量不会提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、变量只能在当前作用域访问</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、禁止重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">4</span>; <span class="comment">// Identifier 'c' has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><strong>暂时性死区</strong><br>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h2 id="1-3-let与const区别"><a href="#1-3-let与const区别" class="headerlink" title="1.3 let与const区别"></a>1.3 let与const区别</h2><p>1.const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>2.const 一旦声明必须立即初始化</p>
<p>关于 const 声明的变量不可修改，有一个值得注意的地方就是用 const 声明一个对象。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tom = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    city: <span class="string">'shanghai'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.age = <span class="number">19</span>; <span class="comment">// 这是可以的</span></span><br></pre></td></tr></table></figure>
<p>const声明的对象是只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。如果需要整个对象都不可修改，可以使用 <code>Object.freeze</code></p>
<h2 id="1-4-循环中的块级作用域"><a href="#1-4-循环中的块级作用域" class="headerlink" title="1.4 循环中的块级作用域"></a>1.4 循环中的块级作用域</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/什么是尾递归/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/21/什么是尾递归/" class="post-title-link" itemprop="http://yoursite.com/index.html">什么是尾递归、尾调用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-21 16:42:31" itemprop="dateCreated datePublished" datetime="2019-02-21T16:42:31+08:00">2019-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 18:26:44" itemprop="dateModified" datetime="2019-02-22T18:26:44+08:00">2019-02-22</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>参考地址 <a href="http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">es6 尾调用优化</a></p>
</blockquote>
<h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>尾调用(<code>Tail Call</code>)是函数编程的一个重要概念： 是指某个函数的最后一步调用另一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> g(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>f</code> 函数的最后一步调用<code>g</code>函数，这就称作尾调用。  </p>
<p>以下3种情况不属于尾调用：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。 </p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。<br>函数调用会在内存中形成一个’调用记录‘，也叫’调用帧‘，保存调用位置和内部变量等信息，如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在A的调用帧上方，还会形成一个B的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。  </p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。  </p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。  </p>
<p>注意，<strong>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。  </p>
<h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？  </p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>，调用尾递归函数<code>tailFactorial</code>，看起来就正常多了。  </p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。  </p>
<p>第二种方法就简单多了，就是<strong>采用 ES6 的函数默认值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<p><strong>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</strong></p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<p>func.arguments：返回调用时函数的参数。<br>func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。  </p>
<p>那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/javascript对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/21/javascript对象/" class="post-title-link" itemprop="http://yoursite.com/index.html">javascript 对象</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-21 16:27:39" itemprop="dateCreated datePublished" datetime="2019-02-21T16:27:39+08:00">2019-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-25 11:22:47" itemprop="dateModified" datetime="2019-02-25T11:22:47+08:00">2019-02-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>可以通过对象直接量，关键字 new 和 <code>Object.create()</code>(EMCAScript5 中)函数来创建对象。 </p>
<h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let newObject = &#123;&#125;</span><br><span class="line">let point = &#123;x: 0, y: 1, &apos;for&apos;: 2&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">注：在 EMCAScript5 中保留字可以不带引号直接作为属性名，EMCAScript3 中需要带引号</span><br><span class="line"></span><br><span class="line">对象直接量是一个表达式，每次运算都会创建并初始化一个新对象</span><br><span class="line"></span><br><span class="line">### 关键字 new  </span><br><span class="line">关键字 new 后面跟一个函数调用。这里的函数称为**构造函数`constructor`**。JavaScript 语言核心中的原始类型都包含内置构造函数。 </span><br><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line">let newOb = new Object()</span><br><span class="line">let a = new Array() //[]</span><br><span class="line">let d = new Date() // Fri Jan 11 2019 11:26:36 GMT+0800 (中国标准时间)</span><br><span class="line">let r = new RegExp(&apos;js&apos;) //模式匹配的RegExp对象</span><br></pre></td></tr></table></figure>
<p>除了内置的构造函数，还可以通过自定义的构造函数来初始化对象  </p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在了解第三种创建方式之前，我们需要了解一下原型<br>每一个 JavaScript 对象(null 除外) 都和另一个对象相关联。“另一个”对象就是<strong>原型</strong>，每一个对象都是从原型继承属性。  </p>
<p>所有通过<code>对象直接量</code>创建的对象都具有同一个原型对象<code>Object.prototype</code>。<br>通过关键字<code>new</code>和构造函数调用创建的对象的<strong>原型</strong>就是构造函数的<code>prototype</code>属性的值。 </p>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h4><p>这里解释一下<code>__proto__</code>属性(在 es6 中标准化，用于保证兼容)，它是<strong>对象</strong>的原型属性，用于继承属性，这个属性十分重要，经常吧“o 的原型属性”称为“o 的原型”，原型属性在实例对象创建之初就设置好了。<code>__proto__</code>属性指向的是该实例的原型（父元素）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>
<p>采用上述两种方式创建对象<code>a</code> ,<code>a</code>的原型属性会指向<code>Object</code>的<strong>原型对象</strong>，即<code>Object.prototype</code>，比较特殊的是<code>Object</code>本身的原型属性指向<code>null</code><br><img src="/images/img-0.png" alt="filename already exists, renamed"> </p>
<blockquote>
<p>不建议修改对象原型属性，使用这个种方式改变和继承属性严重影响性能，如果想创建一个新的对象并且继承<code>[[prototype]]</code>的对象可以使用 <code>Object.create([[prototype]])</code><br><code>__proto__</code>属性 不被推荐使用，现在可以通过<code>Object.getPrototypeOf/Reflect.getPrototypeOf</code>和<code>Object.setPrototypeOf/Reflect.setPrototypeOf</code>（尽管如此，设置对象的<code>[[Prototype]]</code>是一个缓慢的操作，如果性能是一个问题，应该避免）。</p>
</blockquote>
<blockquote>
<p><code>Object.getPrototypeOf(object)</code> 返回的是其原型对象  </p>
</blockquote>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h4><p> <code>prototype</code>是每一函数都包含的属性，它指向一个对象，称这个对象为“原型对象” 将函数作为构造函数的时候，新创建的对象会从“原型对象”上继承属性。</p>
<p> 现在来看一个自定义构造函数的例子，看它的原型链和 prototype 的指向</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{
}

<span class="keyword">let</span> f = <span class="keyword">new</span> foo()

</code></pre>
<p>这里有个比较特殊的是<code>Object</code> 和<code>Function</code>是相互继承的<br><code>Function.__proto__ === Function.prototype //true</code><br><code>Object.__proto__ === Function.prototype  //true</code><br><code>Function.prototype.__proto__ === Object.prototype //true</code><br><code>Object.prototype._proto__ === null  //true</code>  </p>
<p><img src="/images/IUyLAwjY24GBa466s7Eq.png" alt="upload successful">  </p>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h4><p>每个 JavaScript 函数都拥有一个<code>prototype</code>属性，<code>prototype</code>属性的值是一个对象，它函数一个不可枚举的属性<code>constructor</code> ，<code>constructor</code> 的值是一个函数对象，这个函数该对象的构造函数，所有函数最终都是由<code>Function()</code>构造函数得来，所以<code>constructor</code>属性的终点就是<code>Function()</code>。  </p>
<p><img src="/images/r3HE4kNRo6vlSew6uxS5.png" alt="upload successful">  </p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>EMCAScript5 定义了<code>Object.create()</code>方法，它创建一个新对象，其中这个对象的原型是该方法的第一个参数  </p>
<pre><code class="javascript"><span class="comment">// 创建一个原型为null的空对象，这将会创造一个没有原型的新对象，对象不会继承任何东西，也不包含任何基础方法，如 toString</span>
o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);

o = {};
<span class="comment">// 以字面量方式创建的空对象就相当于:</span>
o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);

</code></pre>
<p> 总结一下： </p>
<ol>
<li><p>我们需要牢记两点：①<strong>proto</strong>和 constructor 属性是对象所独有的；② prototype 属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和 constructor 属性。</p>
</li>
<li><p><strong>proto</strong>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象（父对象）里找，一直找，直到<strong>proto</strong>属性的终点 null，然后返回 undefined，通过<strong>proto</strong>属性将对象连接起来的这条链路即我们所谓的原型链。</p>
</li>
<li><p>prototype 属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即 f1.<strong>proto</strong> === Foo.prototype。</p>
</li>
<li><p>constructor 属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向 Function()。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/07/kg_02/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lethe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lethe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/07/kg_02/" class="post-title-link" itemprop="http://yoursite.com/index.html">知识表示与知识建模</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-07 10:06:54" itemprop="dateCreated datePublished" datetime="2019-01-07T10:06:54+08:00">2019-01-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-21 16:29:54" itemprop="dateModified" datetime="2019-02-21T16:29:54+08:00">2019-02-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><p>知识表示的重要性，知识是智能的基础<br>特点：相对正确性  可表示性 可利用性 不确定性<br>分类： 尝试性知识  领域性知识 事实性知识  过程性知识 控制知识  确定性知识 不确定性知识  逻辑性知识  形象性知识 </p>
<p>早期的知识表示  </p>
<ul>
<li>一阶谓词逻辑 first-order logic</li>
<li><p>产生式规则<br>-框架</p>
</li>
<li><p>RDF 和 RDFS Scheme’</p>
</li>
<li>SPARQL查询语言</li>
<li>Json-LD RDFa HTML5 MicroData  </li>
</ul>
<p>语义网 web sematic </p>
<p>RDF Resource Descripetion Framework </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lethe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lethe</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  

  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
